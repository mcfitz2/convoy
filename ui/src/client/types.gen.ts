// This file is auto-generated by @hey-api/openapi-ts

export type APIResponse = {
    message: string;
    status: Status;
};

export type AssignedTaskSupplySchema = {
    quantity?: number;
    supply_id: string;
};

export type CompleteTaskSchema = {
    id: string;
    completed?: boolean;
    completed_date: Date;
    completed_meter_reading: number;
    notes?: string | null;
};

export type CreateMachineSchema = {
    make: string;
    model: string;
    year: number;
    image?: string | null;
    meter_unit: string;
};

export type CreateTaskDefinitionSchema = {
    description: string;
    time_interval: number;
    meter_interval: number;
    recurring?: boolean | null;
    notes?: string | null;
    machine_id: string | null;
    initial_due_meter?: number | null;
    initial_due_date?: Date | null;
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

export type Machine = {
    id?: string;
    meter_unit: string;
    make: string;
    model: string;
    year: number;
    image: string;
    purchase_date?: Date | null;
};

export type MachineSchema = {
    id: string;
    make: string;
    model: string;
    year: number;
    image?: string | null;
    meter_unit: string;
    meter_readings: Array<MeterReading>;
    task_definitions: Array<TaskDefinition>;
    tasks: Array<TaskSchema>;
    readonly current_meter_reading: number | null;
    readonly name: number;
};

export type MeterReading = {
    id?: string;
    value: number;
    timestamp?: Date;
    machine_id?: string | null;
};

export type MeterReadingSchema = {
    id?: string;
    value: number;
    timestamp?: Date;
    machine_id: string | null;
    machine: Machine;
};

export type Part = {
    id?: string;
    name: string;
    link?: string | null;
    supply_id?: string;
};

export type Status = 'SUCCESS' | 'ERROR';

export type Supply = {
    id?: string;
    name: string;
    unit: string;
    quantity_on_hand?: number;
    machine_id?: string | null;
};

export type SupplySchema = {
    id?: string;
    name: string;
    unit: string;
    quantity_on_hand?: number;
    parts?: Array<Part>;
    machine_id: string | null;
};

export type TaskDefinition = {
    id?: string;
    description: string;
    time_interval: number;
    meter_interval: number;
    recurring?: boolean | null;
    notes?: string | null;
    machine_id?: string | null;
};

export type TaskDefinitionSchema = {
    id: string;
    description: string;
    time_interval: number;
    meter_interval: number;
    recurring?: boolean | null;
    notes?: string | null;
    machine_id: string | null;
    supplies: Array<TaskSupplySchema>;
};

export type TaskSchema = {
    id?: string;
    completed?: boolean;
    completed_date?: Date | null;
    completed_meter_reading?: number | null;
    due_date: Date;
    due_meter_reading?: number;
    notes?: string | null;
    task_definition_id: string | null;
    task_definition: TaskDefinitionSchema | null;
    machine_id: string | null;
    machine: Machine;
    readonly due_meter_ago: number;
    readonly due_days_ago: number;
    readonly overdue_reason: string;
};

export type TaskSupplySchema = {
    quantity?: number;
    supply_id: string;
    supply: Supply;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type GetMachinesResponse = Array<MachineSchema>;

export type CreateMachineData = {
    requestBody: CreateMachineSchema;
};

export type CreateMachineResponse = MachineSchema;

export type GetSuppliesResponse = Array<SupplySchema>;

export type CreateSupplyData = {
    requestBody: SupplySchema;
};

export type CreateSupplyResponse = SupplySchema;

export type DeleteSupplyData = {
    supplyId: unknown;
};

export type DeleteSupplyResponse = SupplySchema;

export type UpdateSupplyData = {
    requestBody: SupplySchema;
    supplyId: string;
};

export type UpdateSupplyResponse = SupplySchema;

export type AssignSuppliesData = {
    machineId: string;
    requestBody: Array<AssignedTaskSupplySchema>;
    taskDefId: string;
};

export type AssignSuppliesResponse = APIResponse;

export type GetMachineData = {
    machineId: string;
};

export type GetMachineResponse = MachineSchema;

export type DeleteMachineData = {
    machineId: string;
};

export type DeleteMachineResponse = MachineSchema;

export type UpdateMachineData = {
    machineId: string;
    requestBody: CreateMachineSchema;
};

export type UpdateMachineResponse = MachineSchema;

export type GetReadingsData = {
    machineId: string;
};

export type GetReadingsResponse = Array<MeterReadingSchema>;

export type CreateReadingData = {
    machineId: string;
    requestBody: MeterReading;
};

export type CreateReadingResponse = MeterReading;

export type GetReadingData = {
    machineId: string;
    readingId: string;
};

export type GetReadingResponse = MeterReading;

export type GetTasksData = {
    machineId: string;
};

export type GetTasksResponse = Array<TaskSchema>;

export type GetTaskData = {
    machineId: string;
    taskId: string;
};

export type GetTaskResponse = TaskSchema;

export type GetTaskDefinitionsData = {
    machineId: string;
};

export type GetTaskDefinitionsResponse = Array<TaskDefinitionSchema>;

export type CreateTaskDefinitionData = {
    machineId: string;
    requestBody: CreateTaskDefinitionSchema;
};

export type CreateTaskDefinitionResponse = TaskDefinition;

export type GetTaskDefinitionData = {
    machineId: string;
    taskDefinitionId: string;
};

export type GetTaskDefinitionResponse = TaskDefinitionSchema;

export type DeleteTaskData = {
    taskId: string;
};

export type DeleteTaskResponse = TaskSchema;

export type DeleteTaskDefinitionData = {
    taskId: string;
};

export type DeleteTaskDefinitionResponse = TaskDefinitionSchema;

export type CompleteTaskData = {
    requestBody: CompleteTaskSchema;
    taskId: string;
};

export type CompleteTaskResponse = TaskSchema;

export type $OpenApiTs = {
    '/api/v1/machines': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MachineSchema>;
            };
        };
        post: {
            req: CreateMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/supplies': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<SupplySchema>;
            };
        };
        post: {
            req: CreateSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/supplies/{supply_id}': {
        delete: {
            req: DeleteSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: UpdateSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/task_definitions/{task_def_id}/supplies': {
        post: {
            req: AssignSuppliesData;
            res: {
                /**
                 * Successful Response
                 */
                200: APIResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}': {
        get: {
            req: GetMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: UpdateMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/readings': {
        get: {
            req: GetReadingsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MeterReadingSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateReadingData;
            res: {
                /**
                 * Successful Response
                 */
                200: MeterReading;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/readings/{reading_id}': {
        get: {
            req: GetReadingData;
            res: {
                /**
                 * Successful Response
                 */
                200: MeterReading;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/tasks': {
        get: {
            req: GetTasksData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/tasks/{task_id}': {
        get: {
            req: GetTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/task_definitions': {
        get: {
            req: GetTaskDefinitionsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskDefinitionSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateTaskDefinitionData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskDefinition;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/task_definitions/{task_definition_id}': {
        get: {
            req: GetTaskDefinitionData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskDefinitionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/tasks/{task_id}': {
        delete: {
            req: DeleteTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/task_definitions/{task_id}': {
        delete: {
            req: DeleteTaskDefinitionData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskDefinitionSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/tasks/{task_id}/complete': {
        post: {
            req: CompleteTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
};

export type GetMachinesResponseTransformer = (data: any) => Promise<GetMachinesResponse>;

export type MachineSchemaModelResponseTransformer = (data: any) => MachineSchema;

export type MeterReadingModelResponseTransformer = (data: any) => MeterReading;

export const MeterReadingModelResponseTransformer: MeterReadingModelResponseTransformer = data => {
    if (data?.timestamp) {
        data.timestamp = new Date(data.timestamp);
    }
    return data;
};

export type TaskSchemaModelResponseTransformer = (data: any) => TaskSchema;

export const TaskSchemaModelResponseTransformer: TaskSchemaModelResponseTransformer = data => {
    if (data?.due_date) {
        data.due_date = new Date(data.due_date);
    }
    return data;
};

export const MachineSchemaModelResponseTransformer: MachineSchemaModelResponseTransformer = data => {
    if (Array.isArray(data?.meter_readings)) {
        data.meter_readings.forEach(MeterReadingModelResponseTransformer);
    }
    if (Array.isArray(data?.tasks)) {
        data.tasks.forEach(TaskSchemaModelResponseTransformer);
    }
    return data;
};

export const GetMachinesResponseTransformer: GetMachinesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(MachineSchemaModelResponseTransformer);
    }
    return data;
};

export type CreateMachineResponseTransformer = (data: any) => Promise<CreateMachineResponse>;

export const CreateMachineResponseTransformer: CreateMachineResponseTransformer = async (data) => {
    MachineSchemaModelResponseTransformer(data);
    return data;
};

export type GetMachineResponseTransformer = (data: any) => Promise<GetMachineResponse>;

export const GetMachineResponseTransformer: GetMachineResponseTransformer = async (data) => {
    MachineSchemaModelResponseTransformer(data);
    return data;
};

export type DeleteMachineResponseTransformer = (data: any) => Promise<DeleteMachineResponse>;

export const DeleteMachineResponseTransformer: DeleteMachineResponseTransformer = async (data) => {
    MachineSchemaModelResponseTransformer(data);
    return data;
};

export type UpdateMachineResponseTransformer = (data: any) => Promise<UpdateMachineResponse>;

export const UpdateMachineResponseTransformer: UpdateMachineResponseTransformer = async (data) => {
    MachineSchemaModelResponseTransformer(data);
    return data;
};

export type GetReadingsResponseTransformer = (data: any) => Promise<GetReadingsResponse>;

export type MeterReadingSchemaModelResponseTransformer = (data: any) => MeterReadingSchema;

export const MeterReadingSchemaModelResponseTransformer: MeterReadingSchemaModelResponseTransformer = data => {
    if (data?.timestamp) {
        data.timestamp = new Date(data.timestamp);
    }
    return data;
};

export const GetReadingsResponseTransformer: GetReadingsResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(MeterReadingSchemaModelResponseTransformer);
    }
    return data;
};

export type CreateReadingResponseTransformer = (data: any) => Promise<CreateReadingResponse>;

export const CreateReadingResponseTransformer: CreateReadingResponseTransformer = async (data) => {
    MeterReadingModelResponseTransformer(data);
    return data;
};

export type GetReadingResponseTransformer = (data: any) => Promise<GetReadingResponse>;

export const GetReadingResponseTransformer: GetReadingResponseTransformer = async (data) => {
    MeterReadingModelResponseTransformer(data);
    return data;
};

export type GetTasksResponseTransformer = (data: any) => Promise<GetTasksResponse>;

export const GetTasksResponseTransformer: GetTasksResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaskSchemaModelResponseTransformer);
    }
    return data;
};

export type GetTaskResponseTransformer = (data: any) => Promise<GetTaskResponse>;

export const GetTaskResponseTransformer: GetTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type DeleteTaskResponseTransformer = (data: any) => Promise<DeleteTaskResponse>;

export const DeleteTaskResponseTransformer: DeleteTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type CompleteTaskResponseTransformer = (data: any) => Promise<CompleteTaskResponse>;

export const CompleteTaskResponseTransformer: CompleteTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};