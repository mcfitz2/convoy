// This file is auto-generated by @hey-api/openapi-ts

export type DueReason = 'TIME' | 'METER' | 'BOTH' | 'NOT_DUE';

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

export type MachineSchema = {
    id?: string;
    vin?: string | null;
    meter_unit: string;
    make: string;
    model: string;
    year: number;
    image?: string | null;
    purchase_date?: Date | null;
    meter_readings?: Array<MeterReadingSchema> | null;
    tasks?: Array<TaskSchema> | null;
    current_meter_reading?: number | null;
};

export type MachineUpdateSchema = {
    vin?: string | null;
    meter_unit?: string | null;
    make?: string | null;
    model?: string | null;
    year?: number | null;
    image?: string | null;
    purchase_date?: Date | null;
};

export type MeterReadingSchema = {
    id?: string | null;
    value: number;
    timestamp?: Date;
    machine_id?: string | null;
};

export type PartSchema = {
    id?: string;
    name: string;
    link: string | null;
    supply_id?: string | null;
    supply?: SupplySchema | null;
};

export type SupplySchema = {
    id?: string;
    name: string;
    unit: string;
    quantity_on_hand: number;
    parts?: Array<PartSchema>;
    machine_id?: string | null;
    task_supplies?: Array<TaskSupplySchema>;
};

export type SupplyUpdateSchema = {
    name?: string | null;
    unit?: string | null;
    quantity_on_hand: number | null;
    parts?: Array<PartSchema> | null;
    machine_id?: string | null;
    task_supplies?: Array<TaskSupplySchema>;
};

export type TaskCompleteSchema = {
    notes?: string | null;
    completed_date: Date;
    completed_meter_reading: number;
};

export type TaskCreateSchema = {
    task_supplies?: Array<TaskSupplySchema>;
    description: string;
    time_interval: number;
    meter_interval: number;
    recurring: boolean;
    notes?: string | null;
    due_date?: Date | null;
    due_meter_reading?: number | null;
};

export type TaskDetailedState = {
    state: TaskDueState;
    due_reason?: DueReason;
};

export type TaskDueState = 'OVERDUE' | 'DUE' | 'UPCOMING' | 'COMPLETED';

export type TaskSchema = {
    id?: string;
    description: string;
    time_interval: number;
    meter_interval: number;
    recurring?: boolean;
    notes: string | null;
    completed?: boolean;
    completed_date?: Date | null;
    completed_meter_reading?: number | null;
    due_date: Date;
    due_meter_reading: number;
    todoist_task_id?: string | null;
    machine_id: string;
    task_supplies?: Array<TaskSupplySchema>;
    due_meter_ago?: number | null;
    due_days_ago?: number | null;
    detailed_state?: TaskDetailedState | null;
};

export type TaskSupplySchema = {
    id?: string;
    quantity_required: number;
    supply_id: string;
    supply: SupplySchema;
    task_id: string;
    task: TaskSchema;
};

export type TasksByStateSchema = {
    overdue?: Array<TaskSchema>;
    due?: Array<TaskSchema>;
    upcoming?: Array<TaskSchema>;
    completed?: Array<TaskSchema>;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type UpdateMachineData = {
    machineId: string;
    requestBody: MachineUpdateSchema;
};

export type UpdateMachineResponse = MachineSchema;

export type DeleteMachineData = {
    machineId: string;
};

export type DeleteMachineResponse = MachineSchema;

export type GetMachineData = {
    machineId: string;
};

export type GetMachineResponse = MachineSchema;

export type GetMachinesResponse = Array<MachineSchema>;

export type CreateMachineData = {
    requestBody: MachineSchema;
};

export type CreateMachineResponse = MachineSchema;

export type CreateReadingData = {
    machineId: string;
    requestBody: MeterReadingSchema;
};

export type CreateReadingResponse = MeterReadingSchema;

export type DeleteTaskData = {
    machineId: string;
    taskId: string;
};

export type DeleteTaskResponse = TaskSchema;

export type GetTaskData = {
    machineId: string;
    taskId: string;
};

export type GetTaskResponse = TaskSchema;

export type GetTasksData = {
    machineId: string;
};

export type GetTasksResponse = Array<TaskSchema>;

export type CreateTaskData = {
    machineId: string;
    requestBody: TaskCreateSchema;
};

export type CreateTaskResponse = TaskSchema;

export type GetAllTasksResponse = Array<TaskSchema>;

export type GetAllTasksByStateResponse = TasksByStateSchema;

export type CompleteTaskData = {
    machineId: string;
    requestBody: TaskCompleteSchema;
    taskId: string;
};

export type CompleteTaskResponse = TaskSchema;

export type UpdateSupplyData = {
    requestBody: SupplyUpdateSchema;
    supplyId: string;
};

export type UpdateSupplyResponse = SupplySchema;

export type DeleteSupplyData = {
    supplyId: unknown;
};

export type DeleteSupplyResponse = SupplySchema;

export type GetSupplyData = {
    supplyId: unknown;
};

export type GetSupplyResponse = SupplySchema;

export type GetSuppliesResponse = Array<SupplySchema>;

export type CreateSupplyData = {
    requestBody: SupplySchema;
};

export type CreateSupplyResponse = SupplySchema;

export type $OpenApiTs = {
    '/api/v1/machines/{machine_id}': {
        patch: {
            req: UpdateMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MachineSchema>;
            };
        };
        post: {
            req: CreateMachineData;
            res: {
                /**
                 * Successful Response
                 */
                200: MachineSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/readings': {
        post: {
            req: CreateReadingData;
            res: {
                /**
                 * Successful Response
                 */
                200: MeterReadingSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/tasks/{task_id}': {
        delete: {
            req: DeleteTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/machines/{machine_id}/tasks': {
        get: {
            req: GetTasksData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: CreateTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/tasks': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskSchema>;
            };
        };
    };
    '/api/v1/tasks/by-state': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: TasksByStateSchema;
            };
        };
    };
    '/api/v1/machines/{machine_id}/tasks/{task_id}/complete': {
        post: {
            req: CompleteTaskData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/supplies/{supply_id}': {
        patch: {
            req: UpdateSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/api/v1/supplies': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: Array<SupplySchema>;
            };
        };
        post: {
            req: CreateSupplyData;
            res: {
                /**
                 * Successful Response
                 */
                200: SupplySchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
};

export type CreateReadingResponseTransformer = (data: any) => Promise<CreateReadingResponse>;

export type MeterReadingSchemaModelResponseTransformer = (data: any) => MeterReadingSchema;

export const MeterReadingSchemaModelResponseTransformer: MeterReadingSchemaModelResponseTransformer = data => {
    if (data?.timestamp) {
        data.timestamp = new Date(data.timestamp);
    }
    return data;
};

export const CreateReadingResponseTransformer: CreateReadingResponseTransformer = async (data) => {
    MeterReadingSchemaModelResponseTransformer(data);
    return data;
};

export type DeleteTaskResponseTransformer = (data: any) => Promise<DeleteTaskResponse>;

export type TaskSchemaModelResponseTransformer = (data: any) => TaskSchema;

export type TaskSupplySchemaModelResponseTransformer = (data: any) => TaskSupplySchema;

export type SupplySchemaModelResponseTransformer = (data: any) => SupplySchema;

export const SupplySchemaModelResponseTransformer: SupplySchemaModelResponseTransformer = data => {
    if (Array.isArray(data?.task_supplies)) {
        data.task_supplies.forEach(TaskSupplySchemaModelResponseTransformer);
    }
    return data;
};

export const TaskSupplySchemaModelResponseTransformer: TaskSupplySchemaModelResponseTransformer = data => {
    if (data?.supply) {
        SupplySchemaModelResponseTransformer(data.supply);
    }
    if (data?.task) {
        TaskSchemaModelResponseTransformer(data.task);
    }
    return data;
};

export const TaskSchemaModelResponseTransformer: TaskSchemaModelResponseTransformer = data => {
    if (data?.due_date) {
        data.due_date = new Date(data.due_date);
    }
    if (Array.isArray(data?.task_supplies)) {
        data.task_supplies.forEach(TaskSupplySchemaModelResponseTransformer);
    }
    return data;
};

export const DeleteTaskResponseTransformer: DeleteTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type GetTaskResponseTransformer = (data: any) => Promise<GetTaskResponse>;

export const GetTaskResponseTransformer: GetTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type GetTasksResponseTransformer = (data: any) => Promise<GetTasksResponse>;

export const GetTasksResponseTransformer: GetTasksResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaskSchemaModelResponseTransformer);
    }
    return data;
};

export type CreateTaskResponseTransformer = (data: any) => Promise<CreateTaskResponse>;

export const CreateTaskResponseTransformer: CreateTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type GetAllTasksResponseTransformer = (data: any) => Promise<GetAllTasksResponse>;

export const GetAllTasksResponseTransformer: GetAllTasksResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(TaskSchemaModelResponseTransformer);
    }
    return data;
};

export type GetAllTasksByStateResponseTransformer = (data: any) => Promise<GetAllTasksByStateResponse>;

export type TasksByStateSchemaModelResponseTransformer = (data: any) => TasksByStateSchema;

export const TasksByStateSchemaModelResponseTransformer: TasksByStateSchemaModelResponseTransformer = data => {
    if (Array.isArray(data?.overdue)) {
        data.overdue.forEach(TaskSchemaModelResponseTransformer);
    }
    if (Array.isArray(data?.due)) {
        data.due.forEach(TaskSchemaModelResponseTransformer);
    }
    if (Array.isArray(data?.upcoming)) {
        data.upcoming.forEach(TaskSchemaModelResponseTransformer);
    }
    if (Array.isArray(data?.completed)) {
        data.completed.forEach(TaskSchemaModelResponseTransformer);
    }
    return data;
};

export const GetAllTasksByStateResponseTransformer: GetAllTasksByStateResponseTransformer = async (data) => {
    TasksByStateSchemaModelResponseTransformer(data);
    return data;
};

export type CompleteTaskResponseTransformer = (data: any) => Promise<CompleteTaskResponse>;

export const CompleteTaskResponseTransformer: CompleteTaskResponseTransformer = async (data) => {
    TaskSchemaModelResponseTransformer(data);
    return data;
};

export type UpdateSupplyResponseTransformer = (data: any) => Promise<UpdateSupplyResponse>;

export const UpdateSupplyResponseTransformer: UpdateSupplyResponseTransformer = async (data) => {
    SupplySchemaModelResponseTransformer(data);
    return data;
};

export type DeleteSupplyResponseTransformer = (data: any) => Promise<DeleteSupplyResponse>;

export const DeleteSupplyResponseTransformer: DeleteSupplyResponseTransformer = async (data) => {
    SupplySchemaModelResponseTransformer(data);
    return data;
};

export type GetSupplyResponseTransformer = (data: any) => Promise<GetSupplyResponse>;

export const GetSupplyResponseTransformer: GetSupplyResponseTransformer = async (data) => {
    SupplySchemaModelResponseTransformer(data);
    return data;
};

export type GetSuppliesResponseTransformer = (data: any) => Promise<GetSuppliesResponse>;

export const GetSuppliesResponseTransformer: GetSuppliesResponseTransformer = async (data) => {
    if (Array.isArray(data)) {
        data.forEach(SupplySchemaModelResponseTransformer);
    }
    return data;
};

export type CreateSupplyResponseTransformer = (data: any) => Promise<CreateSupplyResponse>;

export const CreateSupplyResponseTransformer: CreateSupplyResponseTransformer = async (data) => {
    SupplySchemaModelResponseTransformer(data);
    return data;
};